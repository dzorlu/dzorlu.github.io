<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-01">

<title>Expert Parallel ‚Äì Tinkerings</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-45e8e462cd760eca75dbd85b13f1b7a2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-2a27ec7538e68809fa2de2390dba7afd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Tinkerings</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../posts/"> 
<span class="menu-text">Posts</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Expert Parallel</h1>
  <div class="quarto-categories">
    <div class="quarto-category">distributed-training</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Let‚Äôs distill how to run a Mixture-of-Experts (MoE) model with expert parallelism with example.</p>
<p>The setup is 8 GPUs using a 2-D device mesh with Expert Parallel (EP) and FSDP2 (fully_shard).</p>
<p>This short post explains who stores which weights, where all-to-all happens, and includes minimal code (meshes and wrapping).</p>
<hr>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<ul>
<li><strong>Columns move tokens. Rows share weights.</strong></li>
<li><strong>Cols</strong> (dp_shard_in_ep) = EP axis ‚Üí which experts live where + token all-to-all.</li>
<li><strong>Rows</strong> (dp_shard_mod_ep) = FSDP axis ‚Üí how owned experts are sharded.</li>
<li><strong>Non-MoE</strong>: FSDP(8) across all ranks (no persistent replication).</li>
<li><strong>Experts</strong>: EP(2) across columns (ownership) √ó FSDP(4) across rows (shards).</li>
<li><strong>EP all-to-all</strong> is row-local pairs: (0‚ÜîÔ∏é1), (2‚ÜîÔ∏é3), (4‚ÜîÔ∏é5), (6‚ÜîÔ∏é7). Microbatches can differ (variable-size A2A handles it).</li>
</ul>
<hr>
</section>
<section id="device-mesh-rank-layout" class="level2">
<h2 class="anchored" data-anchor-id="device-mesh-rank-layout">Device Mesh &amp; Rank Layout</h2>
<p>Arrange 8 GPUs as a 4√ó2 grid:</p>
<pre><code>(rows, cols) ‚Üí rank
(0,0)‚Üí0   (0,1)‚Üí1
(1,0)‚Üí2   (1,1)‚Üí3
(2,0)‚Üí4   (2,1)‚Üí5
(3,0)‚Üí6   (3,1)‚Üí7</code></pre>
<ul>
<li><strong>Rows</strong> (dp_shard_mod_ep) size 4 ‚Üí FSDP sharding axis for experts.</li>
<li><strong>Cols</strong> (dp_shard_in_ep) size 2 ‚Üí EP ownership + row-local all-to-all.</li>
<li><strong>Flattened dp</strong> view (rows√ócols) size 8 ‚Üí dataloader + FSDP for non-MoE.</li>
</ul>
<p>Here is the pytorch code.</p>
<pre><code>dp_shard_in_ep = ep_size                # borrowed by EP (forms EP groups)
dp_shard_mod_ep = dp_shard // ep_size   # leftover for FSDP sharding. borrowing!

# Create the 2D mesh
device_mesh = init_device_mesh(
    "cuda",
    (dp_shard_mod_ep, dp_shard_in_ep),
    mesh_dim_names=("dp_shard", "ep"),
)

# Create aliases for DP
# DP will be used for data loading
device_mesh[("dp_shard", "ep")]._flatten(mesh_dim_name="dp")

dp_mesh  = device_mesh["dp"]     # size = R*C = 8  -&gt; used for non-MoE FSDP
row_mesh = device_mesh["dp_shard"]   # size = R   = 4  -&gt; used for expert FSDP (inside each column)
col_mesh = device_mesh["ep"]   # size = C   = 2  -&gt; used for EP ownership + a2a</code></pre>
<hr>
</section>
<section id="who-stores-which-expert" class="level2">
<h2 class="anchored" data-anchor-id="who-stores-which-expert">Who Stores Which Expert?</h2>
<p>Assume 8 experts <code>E0..E7</code>. With EP=2: - <strong>Column 0</strong> owns experts E0‚ÄìE3 (no copy of E4‚ÄìE7). - <strong>Column 1</strong> owns experts E4‚ÄìE7 (no copy of E0‚ÄìE3). - Inside each column, FSDP(4) shards the owned experts across the 4 rows. - This makes expert-to-expert communication possible. <code>Rank 0</code> has <code>E0‚ÄìE3</code> and <code>Rank 1</code> has <code>E4-E7</code>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Rank</th>
<th>Column owns</th>
<th>This rank holds (expert weights)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0 = (0,0)</td>
<td>E0‚ÄìE3</td>
<td>1/4 shard of E0‚ÄìE3</td>
</tr>
<tr class="even">
<td>2 = (1,0)</td>
<td>E0‚ÄìE3</td>
<td>1/4 shard of E0‚ÄìE3</td>
</tr>
<tr class="odd">
<td>4 = (2,0)</td>
<td>E0‚ÄìE3</td>
<td>1/4 shard of E0‚ÄìE3</td>
</tr>
<tr class="even">
<td>6 = (3,0)</td>
<td>E0‚ÄìE3</td>
<td>1/4 shard of E0‚ÄìE3</td>
</tr>
<tr class="odd">
<td>1 = (0,1)</td>
<td>E4‚ÄìE7</td>
<td>1/4 shard of E4‚ÄìE7</td>
</tr>
<tr class="even">
<td>3 = (1,1)</td>
<td>E4‚ÄìE7</td>
<td>1/4 shard of E4‚ÄìE7</td>
</tr>
<tr class="odd">
<td>5 = (2,1)</td>
<td>E4‚ÄìE7</td>
<td>1/4 shard of E4‚ÄìE7</td>
</tr>
<tr class="even">
<td>7 = (3,1)</td>
<td>E4‚ÄìE7</td>
<td>1/4 shard of E4‚ÄìE7</td>
</tr>
</tbody>
</table>
<p>Non-MoE (embeddings, attention, MLP, norms) are FSDP-sharded 8-way across all ranks (flattened dp). There is no persistent replication.</p>
<hr>
</section>
<section id="where-does-all-to-all-happen" class="level2">
<h2 class="anchored" data-anchor-id="where-does-all-to-all-happen">Where Does All-to-All Happen?</h2>
<p>EP all-to-all is <strong>row-local</strong>:</p>
<ul>
<li>Row 0: GPU0 ‚áÑ GPU1</li>
<li>Row 1: GPU2 ‚áÑ GPU3</li>
<li>Row 2: GPU4 ‚áÑ GPU5</li>
<li>Row 3: GPU6 ‚áÑ GPU7</li>
</ul>
<p>Each rank runs the router on its own microbatch. Tokens are split by destination column (owner of the chosen expert), then a size-exchange + variable-size all-to-all exchanges exactly those slices between the two columns in the same row.</p>
<p>After dispatch, each rank holds only tokens for experts it owns. Expert matmuls then use FSDP across the 4 rows in that column (<code>all-gather</code> ‚Üí <code>compute</code> ‚Üí <code>reduce-scatter</code>). Finally, the inverse all-to-all returns outputs to the source ranks.</p>
<p>Let‚Äôs illustrate the token dispatch operation with a well-annotated code snippet.</p>
<pre><code>def _token_dispatch(self, model, inputs, device_mesh):
    """
        All-to-all communication
        input_splits is different coming from each device (assuming some data parallelism)
    """
    ep_size = device_mesh.shape[0]
    x_gathered, num_tokens_per_expert = inputs
    num_tokens_per_expert_group = num_tokens_per_expert.new_empty(
        num_tokens_per_expert.shape[0]
    )

    # distributed transpose operation.
    # 0th GPU gets all 0th row

    # Preliminary all-to-all to exchange token counts. This is used to
    # calculate the split sizes for the main token all-to-all dispatch.
    #
    # Before (on GPU 0):
    #   `num_tokens_per_expert`: [10, 5, 12, 8, 11, 6, 13, 7]
    #   (Counts of local tokens for all 8 global experts)
    #
    # After (on GPU 0, which hosts experts 0 and 1):
    #   `num_tokens_per_expert_group` is filled with:
    #   [10, 5, | 9, 4, | 14, 2, | 3, 11]
    #   (Counts for my local experts [E0,E1] from GPU0, GPU1, GPU2, GPU3)
    
    dist.all_to_all_single(
        num_tokens_per_expert_group, # output!
        num_tokens_per_expert, # input
        group=device_mesh.get_group(),
    )


    input_splits = num_tokens_per_expert.view(
        ep_size, -1
    ).sum(dim=1).to(torch.device("cpu"))

    output_splits = num_tokens_per_expert_group.view(
        ep_size, -1
    ).sum(dim=1).to(torch.device("cpu"))

    self.input_splits = input_splits.tolist()
    self.output_splits = output_splits.tolist()

    # this is an uneven communication (e.g. ragged), where each GPU receives an uneven amount of tokens.

    # On GPU 0:
    # - Total tokens before send (sum of num_tokens_per_expert): 72
    # - input_splits (how to slice the 72 tokens for sending): [15, 20, 17, 20]
    # - output_splits (how many tokens to expect from each GPU): [15, 13, 16, 14]

    # Before all_to_all, each GPU has a different number of tokens and a different plan:
    # GPU 0: tensor of size 72, sends chunks of [15, 20, 17, 20]
    # GPU 1: (example) tensor of size 80, sends chunks of [13, 25, 22, 20]
    # GPU 2: (example) tensor of size 75, sends chunks of [16, 18, 21, 20]
    # GPU 3: (example) tensor of size 68, sends chunks of [14, 15, 19, 20]

    # After all_to_all on GPU 0:
    # - Receives: 15 from GPU0, 13 from GPU1, 16 from GPU2, 14 from GPU3
    # - Output tensor size = sum(output_splits) = 15 + 13 + 16 + 14 = 58
    # - This new tensor of 58 tokens contains data for GPU 0's local experts (E0, E1),
    #   but is grouped by source GPU, not by expert ID. It needs a local shuffle.

    # all_to_all_single_autograd allows differentiable data transfer
    print(f"{self.output_splits=} {self.input_splits=}")

    x_gathered = all_to_all_single_autograd(
        x_gathered,
        self.output_splits,
        self.input_splits,
        device_mesh.get_group(),
    )

    # num_tokens_per_expert_group
    #   [10, 5, | 9, 4, | 14, 2, | 3, 11]
    # 
    #   x_gathered on GPU 0 (shape: [58, h])
    #  +------------------------------------------------+
    #  |                                                |
    #  |  Block of 15 tokens RECEIVED from GPU 0        |
    #  |  (Contains 10 tokens for MY E0, 5 for MY E1)   |
    #  |                                                |
    #  +------------------------------------------------+  &lt;-- Boundary at index 14
    #  |                                                |
    #  |  Block of 13 tokens RECEIVED from GPU 1        |
    #  |  (Contains 9 tokens for MY E0, 4 for MY E1)    |
    #  |                                                |
    #  +------------------------------------------------+  &lt;-- Boundary at index 27 (14+13)
    #  |                                                |
    #  |  Block of 16 tokens RECEIVED from GPU 2        |
    #  |  (Contains 14 tokens for MY E0, 2 for MY E1)   |
    #  |                                                |
    #  +------------------------------------------------+  &lt;-- Boundary at index 43 (27+16)
    #  |                                                |
    #  |  Block of 14 tokens RECEIVED from GPU 3        |
    #  |  (Contains 3 tokens for MY E0, 11 for MY E1)   |
    #  |                                                |
    #  +------------------------------------------------+  &lt;-- Final boundary at index 57

    #   Target layout for x_gathered (shape: [58, h])
    #  +------------------------------------------------+
    #  |                                                |
    #  |  All 36 tokens for MY Expert 0                 |
    #  |  (Gathered from the 4 blocks above)            |
    #  |                                                |
    #  +------------------------------------------------+  &lt;-- Boundary at index 35
    #  |                                                |
    #  |  All 22 tokens for MY Expert 1                 |
    #  |  (Gathered from the 4 blocks above)            |
    #  |                                                |
    #  +------------------------------------------------+ 

    # target for num_tokens_per_expert_group
    #    [36, 22]


    # Reshape to see GPU-expert structure
    tokens = num_tokens_per_expert_group.view(-1, ep_size)  
    # Shape: [4, 2] where dim0=GPU, dim1=expert
    # [[10,  5],  &lt;- GPU 0: 10 tokens for E0, 5 for E1
    #  [ 9,  4],  &lt;- GPU 1: 9 tokens for E0, 4 for E1
    #  [14,  2],  &lt;- GPU 2: 14 tokens for E0, 2 for E1
    #  [ 3, 11]]  &lt;- GPU 3: 3 tokens for E0, 11 for E1
    expert_per_device = num_tokens_per_expert_group.shape[0] // ep_size
    expert_ids = torch.repeat_interleave(
        torch.arange(expert_per_device).repeat(ep_size).to('cuda'),  # [0, 1, 0, 1, 0, 1, 0, 1] - expert pattern
        num_tokens_per_expert_group  # [10,5,9,4,14,2,3,11] - repeat counts
    )
    
    # index looks like
    # tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 15, 16, 17, 18, 19, 20, 21, 22,
    # 23, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 44, 45, 46,
    # 10, 11, 12, 13, 14, 24, 25, 26, 27, 42, 43, 47, 48, 49, 50, 51, 52, 53,
    # 54, 55, 56, 57])
    self.index = torch.argsort(expert_ids, stable=True)
    x_reorganized = x_gathered[self.index, :]

    # per expert aggregation
    num_tokens_per_expert_group_agg = tokens.sum(dim=1)

    return x_reorganized, num_tokens_per_expert_group_agg</code></pre>
<hr>
</section>
<section id="the-three-boxes-in-the-forward" class="level2">
<h2 class="anchored" data-anchor-id="the-three-boxes-in-the-forward">The Three ‚ÄúBoxes‚Äù in the Forward</h2>
<ol type="1">
<li><p><strong>Non-experts</strong>: FSDP(8) across all ranks</p>
<pre><code>all_gather(8) ‚Üí compute ‚Üí reduce_scatter(8)</code></pre></li>
<li><p><strong>EP dispatch/return</strong>: row-local all-to-all</p>
<pre><code>Pairs: (0‚Üî1), (2‚Üî3), (4‚Üî5), (6‚Üî7). Size-exchange then A2A.</code></pre></li>
<li><p><strong>Experts</strong>: FSDP(4) inside each column</p>
<pre><code>all_gather(4) ‚Üí grouped GEMM ‚Üí reduce_scatter(4)</code></pre></li>
</ol>
<p>For visually initiated, here is how the placement looks:</p>
<p><a href="https://tinkerings.dev/static/moe.html">üéÆ <strong>View Interactive 3D Visualization</strong></a> - See how data flows through the Non-MoE, MoE FSDP, and Token Routing layers.</p>
<hr>
</section>
<section id="minimal-mesh-wrapping" class="level2">
<h2 class="anchored" data-anchor-id="minimal-mesh-wrapping">Minimal Mesh &amp; Wrapping</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co"># 0) EP: assign experts to columns + install dispatch/combine hooks</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">class</span> ExpertParallel(ParallelStyle):</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb7-6"><a href="#cb7-6"></a>        <span class="va">self</span>.input_splits <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="va">self</span>.output_splits <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="co"># performing all-to-all dispatch on the input</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="kw">def</span> _token_dispatch(<span class="va">self</span>, mod, inputs, device_mesh):</span>
<span id="cb7-11"><a href="#cb7-11"></a>        ...</span>
<span id="cb7-12"><a href="#cb7-12"></a></span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="at">@staticmethod</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="kw">def</span> _partition_fn(name, mod, device_mesh):</span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="co"># shard on the expert dimension</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="cf">for</span> name, param <span class="kw">in</span> mod.named_parameters(recurse<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb7-17"><a href="#cb7-17"></a>            dist_param <span class="op">=</span> nn.Parameter(distribute_tensor(param, device_mesh, [Shard(<span class="dv">0</span>)]))</span>
<span id="cb7-18"><a href="#cb7-18"></a>            mod.register_parameter(name, dist_param)</span>
<span id="cb7-19"><a href="#cb7-19"></a></span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="co"># performing all-to-all combine on the output</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>    <span class="kw">def</span> _token_combine(<span class="va">self</span>, mod, routed_output, device_mesh):</span>
<span id="cb7-22"><a href="#cb7-22"></a>        routed_output <span class="op">=</span> all_to_all_single_autograd(</span>
<span id="cb7-23"><a href="#cb7-23"></a>            routed_output,</span>
<span id="cb7-24"><a href="#cb7-24"></a>            <span class="va">self</span>.input_splits,</span>
<span id="cb7-25"><a href="#cb7-25"></a>            <span class="va">self</span>.output_splits,</span>
<span id="cb7-26"><a href="#cb7-26"></a>            device_mesh.get_group(),</span>
<span id="cb7-27"><a href="#cb7-27"></a>        )</span>
<span id="cb7-28"><a href="#cb7-28"></a>        <span class="cf">return</span> routed_output</span>
<span id="cb7-29"><a href="#cb7-29"></a></span>
<span id="cb7-30"><a href="#cb7-30"></a>    <span class="kw">def</span> _apply(<span class="va">self</span>, module: nn.Module, device_mesh: DeviceMesh) <span class="op">-&gt;</span> nn.Module:</span>
<span id="cb7-31"><a href="#cb7-31"></a>        <span class="cf">return</span> distribute_module(</span>
<span id="cb7-32"><a href="#cb7-32"></a>            module,</span>
<span id="cb7-33"><a href="#cb7-33"></a>            device_mesh,</span>
<span id="cb7-34"><a href="#cb7-34"></a>            partition_fn<span class="op">=</span>ExpertParallel._partition_fn,</span>
<span id="cb7-35"><a href="#cb7-35"></a>            input_fn<span class="op">=</span><span class="va">self</span>._token_dispatch,</span>
<span id="cb7-36"><a href="#cb7-36"></a>            output_fn<span class="op">=</span><span class="va">self</span>._token_combine,</span>
<span id="cb7-37"><a href="#cb7-37"></a>        )</span>
<span id="cb7-38"><a href="#cb7-38"></a></span>
<span id="cb7-39"><a href="#cb7-39"></a></span>
<span id="cb7-40"><a href="#cb7-40"></a>parallelize_module(</span>
<span id="cb7-41"><a href="#cb7-41"></a>    model, device_mesh<span class="op">=</span>col_mesh,</span>
<span id="cb7-42"><a href="#cb7-42"></a>    parallelize_plan<span class="op">=</span>{<span class="st">"layers.*.moe.experts"</span>: ExpertParallel()},</span>
<span id="cb7-43"><a href="#cb7-43"></a>)</span>
<span id="cb7-44"><a href="#cb7-44"></a></span>
<span id="cb7-45"><a href="#cb7-45"></a><span class="co"># 1) FSDP on experts (rows): shard column-local experts across rows</span></span>
<span id="cb7-46"><a href="#cb7-46"></a><span class="cf">for</span> tb <span class="kw">in</span> model.transformer_blocks:</span>
<span id="cb7-47"><a href="#cb7-47"></a>    fully_shard(tb.moe.experts, mesh<span class="op">=</span>row_mesh, reshard_after_forward<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-48"><a href="#cb7-48"></a></span>
<span id="cb7-49"><a href="#cb7-49"></a><span class="co"># 2) FSDP on each block (dp): shard non-MoE 8-way</span></span>
<span id="cb7-50"><a href="#cb7-50"></a><span class="cf">for</span> tb <span class="kw">in</span> model.transformer_blocks:</span>
<span id="cb7-51"><a href="#cb7-51"></a>    fully_shard(tb, mesh<span class="op">=</span>dp_mesh, reshard_after_forward<span class="op">=</span><span class="va">False</span>)   <span class="co"># experts already DTensors on rows</span></span>
<span id="cb7-52"><a href="#cb7-52"></a></span>
<span id="cb7-53"><a href="#cb7-53"></a><span class="co"># 3) FSDP on root (dp): embeddings / head / leftovers</span></span>
<span id="cb7-54"><a href="#cb7-54"></a>fully_shard(model, mesh<span class="op">=</span>dp_mesh, reshard_after_forward<span class="op">=</span><span class="va">True</span>)     <span class="co"># True/False per memory tradeoff</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
<section id="pseudo-forward" class="level2">
<h2 class="anchored" data-anchor-id="pseudo-forward">Pseudo-Forward</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> forward_on_rank(row, col, x_rc):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="co"># A) Non-MoE on FSDP: AG(8) ‚Üí compute ‚Üí RS(8)</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    h <span class="op">=</span> non_moE_stack(x_rc)</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="co"># Router: expert id per token (e.g., [2,2,5,1,6,...])</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    eids <span class="op">=</span> router(h)</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="co"># B) EP dispatch within this row: send tokens to owner column</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>    h_owned <span class="op">=</span> ep_a2a_dispatch(h, eids, group<span class="op">=</span>{(row,<span class="dv">0</span>),(row,<span class="dv">1</span>)})</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="co"># C) Experts on owner column: FSDP(4) across rows of this column</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>    y_local <span class="op">=</span> experts_matmul(h_owned)           <span class="co"># AG(4) ‚Üí GEMM ‚Üí RS(4)</span></span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="co"># D) EP combine within this row: inverse A2A back to source rank</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    y <span class="op">=</span> ep_a2a_combine(y_local, eids, group<span class="op">=</span>{(row,<span class="dv">0</span>),(row,<span class="dv">1</span>)})</span>
<span id="cb8-16"><a href="#cb8-16"></a></span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="co"># E) Tail Non-MoE on dp: AG(8) ‚Üí compute ‚Üí RS(8)</span></span>
<span id="cb8-18"><a href="#cb8-18"></a>    out <span class="op">=</span> non_moE_tail(y)</span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="cf">return</span> out</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Backward (intuition)</strong>: EP‚Äôs A2A autograd returns activation grads to sources; expert parameter grads are reduce-scattered across the row group (the 4 that shard that expert). Non-MoE grads reduce-scatter across all 8.</p>
<hr>
</section>
<section id="after-parallelization-expected-placements" class="level2">
<h2 class="anchored" data-anchor-id="after-parallelization-expected-placements">After Parallelization: Expected Placements</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> show_placements(model, keys<span class="op">=</span>(<span class="st">"moe.experts"</span>,<span class="st">"attention"</span>,<span class="st">"router"</span>,<span class="st">"embeddings"</span>,<span class="st">"norm"</span>,<span class="st">"output"</span>)):</span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="cf">for</span> name, p <span class="kw">in</span> model.named_parameters():</span>
<span id="cb9-3"><a href="#cb9-3"></a>        <span class="cf">if</span> <span class="bu">any</span>(k <span class="kw">in</span> name <span class="cf">for</span> k <span class="kw">in</span> keys):</span>
<span id="cb9-4"><a href="#cb9-4"></a>            pl <span class="op">=</span> <span class="bu">getattr</span>(p, <span class="st">"placements"</span>, <span class="va">None</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a>            kind <span class="op">=</span> <span class="st">"DTensor"</span> <span class="cf">if</span> pl <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="st">"LOCAL"</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:&lt;60}</span><span class="ss"> -&gt; </span><span class="sc">{</span>kind<span class="sc">:7}</span><span class="ss"> </span><span class="sc">{</span>pl<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example lines you should see:</p>
<pre><code>tok_embeddings.weight                                   -&gt; DTensor (Shard(dim=0),)
layers.0.attention.wq.weight                            -&gt; DTensor (Shard(dim=0),)
layers.0.feed_forward.router.router.weight              -&gt; DTensor (Shard(dim=0),)
layers.0.feed_forward.experts.w1                        -&gt; DTensor (_StridedShard(dim=0, sf=2), Shard(dim=0))
layers.0.feed_forward.experts.w2                        -&gt; DTensor (_StridedShard(dim=0, sf=2), Shard(dim=0))
layers.0.feed_forward.experts.w3                        -&gt; DTensor (_StridedShard(dim=0, sf=2), Shard(dim=0))
...</code></pre>
<section id="legend" class="level3">
<h3 class="anchored" data-anchor-id="legend">Legend</h3>
<ul>
<li><code>(Shard(dim=0),)</code> ‚Üí Non-MoE params sharded on a 1-D mesh (flattened dp ‚Üí 8-way).</li>
<li><code>(_StridedShard(dim=0, sf=2), Shard(dim=0))</code> ‚Üí Experts are split on <strong>two separete mesh axes</strong> of the same tensor dim-0 (experts):
<ul>
<li><code>Shard(dim=0)</code> on cols (EP ownership).</li>
<li><code>_StridedShard(dim=0, sf=2)</code> on rows (FSDP across 4 rows, after a prior split by 2 cols). <code>sf=2</code> because dim-0 was already split once by the 2 columns</li>
</ul></li>
</ul>
</section>
</section>
<section id="appendix-dataloader-on-flattened-dp." class="level2">
<h2 class="anchored" data-anchor-id="appendix-dataloader-on-flattened-dp.">Appendix: Dataloader on Flattened DP.</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Use the flattened 8-way dp mesh for sampling</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>global_dp_rank <span class="op">=</span> dp_mesh.get_rank()</span>
<span id="cb11-3"><a href="#cb11-3"></a>num_replicas   <span class="op">=</span> dp_mesh.size()</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DistributedSampler, DataLoader</span>
<span id="cb11-6"><a href="#cb11-6"></a>sampler <span class="op">=</span> DistributedSampler(dataset, num_replicas<span class="op">=</span>num_replicas, rank<span class="op">=</span>global_dp_rank)</span>
<span id="cb11-7"><a href="#cb11-7"></a>loader  <span class="op">=</span> DataLoader(dataset, batch_size<span class="op">=</span>per_rank_bsz, sampler<span class="op">=</span>sampler, pin_memory<span class="op">=</span><span class="va">True</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This preserves 8 microbatches per step‚Äîone per rank‚Äîwhile placements and collectives follow the mesh rules above.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tinkerings\.dev");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>