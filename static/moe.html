<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D MoE Data Flow Visualization</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border-radius: 5px;
            color: white;
            font-size: 13px;
        }
        #info h3 {
            margin: 0 0 8px 0;
            color: #0f8;
            font-size: 16px;
        }
        .hint {
            color: #888;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>MoE 3D Data Flow</h3>
        <div>8 GPUs (4 rows × 2 cols)</div>
        <div class="hint">Drag to rotate • Scroll to zoom</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const camera = new THREE.PerspectiveCamera(
            50, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            500
        );
        camera.position.set(35, 30, 70);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 40, 20);
        scene.add(directionalLight);
        
        // Main group for rotation
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        
        // GPU positions: 4 rows × 2 columns
        // Column 0 (left): GPUs 0,2,4,6
        // Column 1 (right): GPUs 1,3,5,7
        const gpuPositions = [
            {x: -8, y: 9, gpu: 0},   // Row 0, Col 0
            {x: 8, y: 9, gpu: 1},    // Row 0, Col 1
            {x: -8, y: 3, gpu: 2},   // Row 1, Col 0
            {x: 8, y: 3, gpu: 3},    // Row 1, Col 1
            {x: -8, y: -3, gpu: 4},  // Row 2, Col 0
            {x: 8, y: -3, gpu: 5},   // Row 2, Col 1
            {x: -8, y: -9, gpu: 6},  // Row 3, Col 0
            {x: 8, y: -9, gpu: 7},   // Row 3, Col 1
        ];
        
        // Create 8 arrows piercing through blocks
        const arrowMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff88,
            emissive: 0x00ff88,
            emissiveIntensity: 0.2
        });
        
        gpuPositions.forEach(pos => {
            // Long arrow shaft along Z-axis
            const shaftGeometry = new THREE.CylinderGeometry(0.4, 0.4, 100, 8);
            const shaft = new THREE.Mesh(shaftGeometry, arrowMaterial);
            shaft.position.set(pos.x, pos.y, 0);
            shaft.rotation.x = Math.PI / 2;
            mainGroup.add(shaft);
            
            // Arrow head
            const coneGeometry = new THREE.ConeGeometry(0.8, 2.5, 8);
            const cone = new THREE.Mesh(coneGeometry, arrowMaterial);
            cone.position.set(pos.x, pos.y, 50);
            cone.rotation.x = Math.PI / 2;
            mainGroup.add(cone);
            
            // GPU label
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 64;
            labelCanvas.height = 64;
            const ctx = labelCanvas.getContext('2d');
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(pos.gpu.toString(), 32, 32);
            
            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
            const labelSprite = new THREE.Sprite(labelMaterial);
            labelSprite.scale.set(3, 3, 1);
            labelSprite.position.set(pos.x, pos.y, -50);
            mainGroup.add(labelSprite);
        });
        
        // Block materials
        const blockMaterials = {
            nonMoe: new THREE.MeshPhongMaterial({
                color: 0x4080ff,
                transparent: true,
                opacity: 0.25
            }),
            moeFsdp: new THREE.MeshPhongMaterial({
                color: 0xff6b6b,
                transparent: true,
                opacity: 0.25
            }),
            routing: new THREE.MeshPhongMaterial({
                color: 0xffdd00,
                transparent: true,
                opacity: 0.25
            })
        };
        
        // Block 1: Non-MoE (all 8 arrows pierce through)
        const nonMoeGeometry = new THREE.BoxGeometry(24, 24, 12);
        const nonMoeBlock = new THREE.Mesh(nonMoeGeometry, blockMaterials.nonMoe);
        nonMoeBlock.position.set(0, 0, -25);
        mainGroup.add(nonMoeBlock);
        
        const nonMoeEdges = new THREE.EdgesGeometry(nonMoeGeometry);
        const nonMoeWireframe = new THREE.LineSegments(
            nonMoeEdges,
            new THREE.LineBasicMaterial({ color: 0x4080ff, linewidth: 2 })
        );
        nonMoeWireframe.position.copy(nonMoeBlock.position);
        mainGroup.add(nonMoeWireframe);
        
        // Block 2: MoE FSDP (2 columns)
        const moeFsdpGeometry = new THREE.BoxGeometry(10, 24, 12);
        
        // Column 0 (left) - GPUs 0,2,4,6
        const moeFsdpCol0 = new THREE.Mesh(moeFsdpGeometry, blockMaterials.moeFsdp);
        moeFsdpCol0.position.set(-8, 0, 0);
        mainGroup.add(moeFsdpCol0);
        
        const moeFsdpCol0Edges = new THREE.EdgesGeometry(moeFsdpGeometry);
        const moeFsdpCol0Wireframe = new THREE.LineSegments(
            moeFsdpCol0Edges,
            new THREE.LineBasicMaterial({ color: 0xff6b6b, linewidth: 2 })
        );
        moeFsdpCol0Wireframe.position.copy(moeFsdpCol0.position);
        mainGroup.add(moeFsdpCol0Wireframe);
        
        // Column 1 (right) - GPUs 1,3,5,7
        const moeFsdpCol1 = new THREE.Mesh(moeFsdpGeometry, blockMaterials.moeFsdp);
        moeFsdpCol1.position.set(8, 0, 0);
        mainGroup.add(moeFsdpCol1);
        
        const moeFsdpCol1Edges = new THREE.EdgesGeometry(moeFsdpGeometry);
        const moeFsdpCol1Wireframe = new THREE.LineSegments(
            moeFsdpCol1Edges,
            new THREE.LineBasicMaterial({ color: 0xff6b6b, linewidth: 2 })
        );
        moeFsdpCol1Wireframe.position.copy(moeFsdpCol1.position);
        mainGroup.add(moeFsdpCol1Wireframe);
        
        // Block 3: Token Routing (pairwise A2A)
        const routingPairs = [
            {gpu1: 0, gpu2: 1, y: 9},   // Row 0
            {gpu1: 2, gpu2: 3, y: 3},   // Row 1
            {gpu1: 4, gpu2: 5, y: -3},  // Row 2
            {gpu1: 6, gpu2: 7, y: -9}   // Row 3
        ];
        
        routingPairs.forEach(pair => {
            // Routing block connecting the pair
            const routingGeometry = new THREE.BoxGeometry(20, 4, 10);
            const routingBlock = new THREE.Mesh(routingGeometry, blockMaterials.routing);
            routingBlock.position.set(0, pair.y, 25);
            mainGroup.add(routingBlock);
            
            const routingEdges = new THREE.EdgesGeometry(routingGeometry);
            const routingWireframe = new THREE.LineSegments(
                routingEdges,
                new THREE.LineBasicMaterial({ color: 0xffdd00, linewidth: 2 })
            );
            routingWireframe.position.copy(routingBlock.position);
            mainGroup.add(routingWireframe);
            
            // Bidirectional arrow showing A2A
            const curve1 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-8, pair.y - 1, 25),
                new THREE.Vector3(0, pair.y - 1.5, 25),
                new THREE.Vector3(8, pair.y - 1, 25)
            ]);
            const tubeGeometry1 = new THREE.TubeGeometry(curve1, 20, 0.2, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            const tube1 = new THREE.Mesh(tubeGeometry1, tubeMaterial);
            mainGroup.add(tube1);
            
            const curve2 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(8, pair.y + 1, 25),
                new THREE.Vector3(0, pair.y + 1.5, 25),
                new THREE.Vector3(-8, pair.y + 1, 25)
            ]);
            const tubeGeometry2 = new THREE.TubeGeometry(curve2, 20, 0.2, 8, false);
            const tube2 = new THREE.Mesh(tubeGeometry2, tubeMaterial);
            mainGroup.add(tube2);
        });
        
        // Add labels
        function createLabel(text, color, position) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(16, 2, 1);
            sprite.position.copy(position);
            return sprite;
        }
        
        mainGroup.add(createLabel('Non-MoE (8-way FSDP)', 0x4080ff, new THREE.Vector3(0, 15, -25)));
        mainGroup.add(createLabel('MoE Col0', 0xff6b6b, new THREE.Vector3(-8, 15, 0)));
        mainGroup.add(createLabel('MoE Col1', 0xff6b6b, new THREE.Vector3(8, 15, 0)));
        mainGroup.add(createLabel('Token Routing (A2A)', 0xffdd00, new THREE.Vector3(0, 15, 25)));
        
        // Add grid for reference
        const gridHelper = new THREE.GridHelper(60, 12, 0x222222, 0x111111);
        gridHelper.position.y = -15;
        scene.add(gridHelper);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Mouse controls
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            mainGroup.rotation.y += deltaX * 0.01;
            mainGroup.rotation.x += deltaY * 0.005;
            mainGroup.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, mainGroup.rotation.x));
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        renderer.domElement.addEventListener('wheel', (e) => {
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
            camera.position.multiplyScalar(zoomFactor);
            
            const dist = camera.position.length();
            if (dist < 40) camera.position.normalize().multiplyScalar(40);
            if (dist > 150) camera.position.normalize().multiplyScalar(150);
            
            camera.lookAt(0, 0, 0);
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>